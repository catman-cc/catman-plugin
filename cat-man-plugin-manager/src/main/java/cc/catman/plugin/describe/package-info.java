package cc.catman.plugin.describe;
// 插件的描述信息相关的内容存放在当前包中.
// 在设计上,一个插件描述信息可能会经过多次转换,比如从最初一组包描述,转为git包描述,再变成maven包描述,最后转为插件包描述.
// 所以插件的描述信息,需要拆分出通用的部分,比如:
// - kind,source,然后每一个插件描述对象还会具有自己特定的内容信息,比如,git类型的插件描述,需要包含git仓库的地址,
// maven类型的插件描述,则需要包含,mvn命令执行的根目录,依次执行的命令,最终生成产物的类型等等.
// 这就意味着,一个插件描述信息在所有的包描述信息中,可能都会需要一个转换操作.

/**
 *  1. finder 获取desc文件,根据desc文件的类型,找到对应的descParser,descParser 会获取两个数据,kind和source.
 *
 *  2. 上下文,根据kind和source找到对应的插件描述文件处理器,处理器调用parser获取自己所需的desc实例.
 *  3. 插件根据desc完成自己的业务,然后根据需要生成新的PluginItem,交给上下文,上下文继续调用1继续处理.
 *  4. 如果插件处理器,完成处理,可以返回一个ClassLoader,这样上下文会返回该ClassLoader.
 *  4. ClassLoader会被包装成一个插件实例,插件实例可能会继续访问插件描述信息,得到一个依赖插件列表.
 *  5. 插件列表调用1递归处理依赖内容.
 *  6. 当获取所有的插件实例之后,或者插件的准备状态结束之后,可以根据配置项选择是否立即启用插件.
 *  7. 插件在启动时,开始陆续发出事件,插件启动前,插件启动后,插件启动失败,插件启动成功,甚至插件在扫描到一个具体的扩展点的时候,也可以发出事件.
 *  9. 插件处于成功状态后,可以开始调用插件的管理操作,比如,暂停插件,加载扩展点,获取扩展点等等.
 *  10. 扩展点的实例化,加载,卸载,禁用,都会触发事件
 *  11. 插件的管理界面会递归调用子插件管理器的管理界面,作为统一的门面模式,以便于方便的管理插件.
 *  12. 插件的卸载操作是先进行禁用操作,然后再进行卸载,禁用和卸载都是从上至下的递归操作.
 *  13. 插件的控制面可以接受一个或一组插件描述信息,进行更新或安装操作.
 *  14. 插件支持语义化的版本控制
 *  15. 插件支持约束条件,来验证是否支持在当前环境运行,语义化的验证写在插件描述信息的constraint列表中,支持表达式语言,目前选择嵌入使用spel,验证不通过的插件将会发出验证不通过异常事件,并根据全局配置选择是中断安装等不同的策略
 */